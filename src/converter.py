"""PDF to Markdown converter using marker-pdf."""

import os
import subprocess
from pathlib import Path
from typing import Optional

from .config import Config


class ConversionError(Exception):
    """Exception raised when PDF conversion fails."""

    pass


def convert_pdf_to_markdown(
    pdf_path: str,
    output_dir: str,
    config: Config,
    progress_callback: Optional[callable] = None,
) -> str:
    """
    Convert PDF to markdown using marker-pdf.

    Args:
        pdf_path: Path to input PDF file
        output_dir: Directory for output markdown file
        config: Configuration object with API key and settings
        progress_callback: Optional callback for progress updates

    Returns:
        str: Path to generated markdown file

    Raises:
        ConversionError: If conversion fails
    """
    pdf_path = Path(pdf_path).resolve()
    output_dir = Path(output_dir).resolve()

    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Build marker_single command
    cmd = [
        "marker_single",
        str(pdf_path),
        "--output_dir",
        str(output_dir),
        "--output_format",
        "markdown",
    ]

    # Add LLM service if enabled (use Gemini)
    if config.use_llm:
        cmd.extend(["--llm_service", "marker.services.gemini.GoogleGeminiService"])

    # Set environment variables
    env = os.environ.copy()
    env["GEMINI_API_KEY"] = config.gemini_api_key

    if progress_callback:
        progress_callback("Starting conversion...")

    try:
        # Execute marker_single command
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,  # Merge stderr into stdout
            env=env,
            text=True,
        )

        # Capture output
        stdout_lines = []

        # Read stdout in real-time
        for line in iter(process.stdout.readline, ""):
            if line:
                stdout_lines.append(line)
                if progress_callback:
                    progress_callback(line.strip())

        # Wait for process to complete
        process.wait()

        # Check return code
        if process.returncode != 0:
            error_msg = "".join(stdout_lines)
            raise ConversionError(
                f"Marker conversion failed with code {process.returncode}:\n{error_msg}"
            )

        # Find the output markdown file
        output_file = find_output_markdown(output_dir, pdf_path.stem)

        if not output_file:
            raise ConversionError(
                f"Conversion appeared to succeed but output file not found in {output_dir}"
            )

        return str(output_file)

    except FileNotFoundError:
        raise ConversionError(
            "marker_single command not found. Please install marker-pdf:\n"
            "pip install marker-pdf[full]"
        )
    except subprocess.SubprocessError as e:
        raise ConversionError(f"Failed to execute marker_single: {str(e)}")
    except Exception as e:
        raise ConversionError(f"Unexpected error during conversion: {str(e)}")


def find_output_markdown(output_dir: Path, pdf_stem: str) -> Optional[Path]:
    """
    Find the output markdown file generated by marker.

    Marker typically creates a subdirectory {pdf_stem} and puts {pdf_stem}.md inside it.

    Args:
        output_dir: Directory containing output files
        pdf_stem: Stem of the original PDF filename

    Returns:
        Path to the markdown file, or None if not found
    """
    # Check for file inside subdirectory (standard marker behavior)
    # output_dir/pdf_stem/pdf_stem.md
    subdir_match = output_dir / pdf_stem / f"{pdf_stem}.md"
    if subdir_match.exists():
        return subdir_match

    # Check for exact match in root (fallback)
    exact_match = output_dir / f"{pdf_stem}.md"
    if exact_match.exists():
        return exact_match

    # Check for any .md files in the specific subdirectory
    subdir = output_dir / pdf_stem
    if subdir.exists() and subdir.is_dir():
        md_files = list(subdir.glob("*.md"))
        if md_files:
            md_files.sort(key=lambda p: p.stat().st_mtime, reverse=True)
            return md_files[0]

    # Check for any .md files in output directory (last resort)
    md_files = list(output_dir.glob("*.md"))

    # Return the most recently created .md file
    if md_files:
        md_files.sort(key=lambda p: p.stat().st_mtime, reverse=True)
        return md_files[0]

    return None


def parse_error_message(error_output: str) -> str:
    """
    Parse error message from marker output and provide actionable advice.

    Args:
        error_output: Raw error output from marker

    Returns:
        str: User-friendly error message with suggestions
    """
    error_lower = error_output.lower()

    # API key errors
    if "api key" in error_lower or "authentication" in error_lower:
        return (
            "API key error: Your Gemini API key may be invalid or expired.\n"
            "Please check your .env file and verify your API key at:\n"
            "https://aistudio.google.com/app/apikey"
        )

    # Out of memory errors
    if "out of memory" in error_lower or "oom" in error_lower:
        return (
            "Out of memory error: The PDF may be too large or complex.\n"
            "Try:\n"
            "  1. Using --no-llm flag for faster processing\n"
            "  2. Processing a smaller PDF\n"
            "  3. Closing other applications to free up memory"
        )

    # GPU/device errors
    if "cuda" in error_lower or "mps" in error_lower or "device" in error_lower:
        return (
            "Device error: Problem with GPU acceleration.\n"
            "Try: python parse_pdf.py --device cpu"
        )

    # Rate limiting
    if "rate limit" in error_lower or "quota" in error_lower:
        return (
            "Rate limit error: You've exceeded the Gemini API rate limit.\n"
            "Please wait a few minutes and try again."
        )

    # Return original error if no specific match
    return error_output
